<!DOCTYPE html>
<html>
<head>
    <title>What does this do?</title>
</head>
<body>
    <h1 id="what-does-this-do">What does this do?</h1>
<p>It creates the infrastructure for reciving messages from RabbitMq.
Also handles faild messages..</p>
<p>Look in the Demo folder to se the usage as wellgit</p>
<h1 id="prerequisites">Prerequisites</h1>
<ul>
<li>The Exchange must be manually declared on rabbit instance for the Rabbit adapter to work</li>
</ul>
<h1 id="workflow-of-the-rabbit-adapter">Workflow of the Rabbit Adapter</h1>
<ul>
<li>Create 2 connections, one for incomming and one for outgoing messages</li>
<li>Creates a _GlobalErrors exchange for notifying.</li>
<li>Create &quot;Dead Letter Exchang&quot; for this consumer type. (many instances of the same type can be run at the same time, but they share the queue infrastructure).</li>
<li>Create &quot;Dead Letter Queue&quot; for this consumer type and attach to &quot;Dead Letter Exchange&quot;.</li>
<li>Create queue for all registerd handlers, if not exists(operation is idempotent).
<ul>
<li>The Dead Letter Exchange from step 2 is set as the DLE of the queue, meaning that &quot;NACK&quot;ing a message from the queue will send it to this exchange.</li>
<li>Attached queue to exchange provided in the connectioninfo, this exchange has to exists prior to staring the consumer.</li>
<li>Start to listen to messages from queue</li>
</ul>
</li>
</ul>
<h2 id="incomming-type-safe-messages-is-handled-in-this-way">Incomming type safe messages is handled in this way.</h2>
<ul>
<li>Get the routing key for the message, read from properties in the &quot;BasicDevliveryEventArgs&quot;</li>
<li>Deserialize the message to the type matching the routing key. You can controll the how the serializer works by implementing the <code>ISerializer</code> interface</li>
<li>Create instance of handler assosiated with the message, using the provided <code>Action</code> delegate.</li>
<li>Invoke the Handle method on the instance with the message.</li>
<li>ACK is sendt to rabbit, this removes the message from the queue;</li>
</ul>
<h2 id="incomming-wildcard-routings">Incomming wildcard routings</h2>
<ul>
<li>Create a generic message with the body as string.</li>
<li>Instanciate the handler that was registerd with routing key</li>
<li>Call the Handle method</li>
<li>ACK is sendt to rabbit, this removes the message from the queue;</li>
</ul>
<h2 id="naming-of-queues">Naming of queues</h2>
<p>Queues will be named by convention.</p>
<p><code>string QueueName = $&quot;{clientName}_{exchangeName}_{routingKey}&quot;;</code></p>
<h2 id="when-handling-fails">When handling fails</h2>
<ul>
<li>Message is NACK'ed.</li>
<li>Rabbit will push the message to the Dead Letter Exchange set on the queue, when the queue was created.</li>
<li>A message will be sent to the exchange in step 2 in of the setup.
<ul>
<li>The message is of type</li>
</ul>
</li>
</ul>
<pre><code class="language-csharp">public class ErrorModel
    {
        public string CorrelationId;
        public string MessageType;
        public string HandlerName;
        public string ServerName;
    }
</code></pre>
<p>This can be used to survie the infratructure.</p>
<h3 id="small-example">Small example.</h3>
<pre><code class="language-csharp">static void Main(string[] args)
{
    //Use any container.. 
    var container = new SimpleFactory.Container(LifeTimeEnum.PerGraph);
    container.Register&lt;MyHandler&gt;();

    //Connectioninfo to the rabbit server. 
    //The ClientName is important, as it is used in the infrastructure to indentify the host. 
    RabbitConnectionInfo connectionInfo = new RabbitConnectionInfo { UserName = &quot;guest&quot;, Password = &quot;guest&quot;, Server = &quot;localhost&quot;, ExchangeName = &quot;Simployer&quot;, ClientName = &quot;MyTestingApp&quot; };

    //Create the RabbitAdapter. This is a spesific implementation for Rabbit.
    IMessageAdapter messageAdapter = new RabbitMessageAdapter(
            connectionInfo,
            //The serializer that will be used by the adapter. This must implement the ISerializer from Itas.Infrastructure.
            new Serializer(),
            //This Func&lt;BasicDeliveryEventArgs&gt; gives you the chance to create a context value for your eventhandler.
            //Setting the ClientContext e.g
            (eventArgs) =&gt; new ClientContext
            {
                CorrelationId = eventArgs.GetCorrelationId(),
                CompanyGuid = eventArgs.GetCustomerGuid(),
                UserGuid = eventArgs.GetUserGuid()
            }
        );

    //Then instanciate the MessageHandler.. Passing in the Adapter. 
    var server = new MessageHandlerEngine(
        messageAdapter,
        //This Func&lt;Type,object&gt; is used instead of taking a dependency on a Container. 
        //Here you can create your scope to for your context

        (t, c) =&gt; container.CreateAnonymousInstance(t, c));

    //Register a typed handler for the Engine. 
    //The engine will ask for an instance of  MessageHandle&lt;MyEventClass&gt; using the above Action&lt;Type,object&gt;. 
    server.AttachMessageHandler&lt;SomethingOccured, MyHandler&gt;();

    //Registering an untyped handler. 
    //Will ask for an instance of the type mapped against this bindingkey. 
    server.AttachGenericMessageHandler&lt;GenericEventHandler&gt;(&quot;#&quot;);

    //Start the server. 
    //The infrastructure will be created on the rabbit server and the adapter will start to recieve the messages. 
    server.StartServer();

    Console.ReadLine();

    //Stop the server to dispose the connections to Rabbit. 
    server.StopServer();
}
</code></pre>
<h2 id="producing-messages-for-rabbitmq">Producing messages for RabbitMQ</h2>
<p>This is a piece of software that takes the burden off the developer when publishing messages/events to RabbitMQ.</p>
<p>It is made as a &quot;singleton&quot; component and should only be instanciated once. Use a &quot;scoped&quot; or &quot;transient&quot; objct that takes this object as a dependency to capture the customer/user context.</p>
<pre><code class="language-csharp">
static void Main(string[] args)
{
    var container = new SimpleFactory.Container();
    var con = new RabbitConnectionInfo
    {
        ClientName = &quot;Listner.Demo&quot;,
        ExchangeName = &quot;Simployer&quot;,
        Server = &quot;localhost&quot;,
        UserName = &quot;guest&quot;,
        Password = &quot;guest&quot;,
        VirtualHost = &quot;/&quot;
    };

    var pub = new PublishEventToRabbit(con, new Serializer());

    container.Register&lt;PublishEventToRabbit&gt;(() =&gt; pub).AsSingleton(); //This is singleton to hold the connection stuff for rabbit. Must be disposed
    container.Register&lt;CustomPublisher&gt;().Transient(); //This is the wrapper to capture the context of the current call
    container.Register&lt;ApplicationContext&gt;(); // this is the actual context.. Very simplefied :) 

    for (var x = 0; x &lt; 10; x++)
    {
        var sender = container.CreateInstance&lt;CustomPublisher&gt;();
        sender.Publish(new SomethingOccured());
    }

    pub.Dispose();
}


public class CustomPublisher
{
    readonly PublishEventToRabbit toRabbit;
    readonly ApplicationContext context;

    public CustomPublisher(PublishEventToRabbit toRabbit, ApplicationContext context)
    {
        this.context = context;
        this.toRabbit = toRabbit;
    }


    public void Publish(object message)
    {
        var ctx = new RabbitEventContext {CorrelationId=context.CorrelationId, CustomerId=context.CompanyGuid, UserId=context.UserId};
        toRabbit.Publish(ctx, message);
    }

}

public class ApplicationContext
{
    public Guid CorrelationId = Guid.NewGuid();
    public Guid UserId = Guid.NewGuid();
    public Guid CompanyGuid = Guid.NewGuid();
}

</code></pre>

    <script>
        var config = {
            startOnLoad: true,
            flowchart:{
                htmlLabels: false,
                useMaxWidth: true
            },
            width: "800px "
        };
        mermaid.initialize(config);
    </script>
</body>
</html>