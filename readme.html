<!DOCTYPE html>
<html>
<head>
    <title>What does this do?</title>
</head>
<body>
    <h1 id="what-does-this-do">What does this do?</h1>
<p>It creates the infrastructure for reciving messages from RabbitMq.
Also handles faild messages, they are posted to a Dead Letter Queue,</p>
<h1 id="workflow-of-the-rabbit-adapter">Workflow of the Rabbit Adapter</h1>
<ul>
<li>Create 2 connections, one for incomming and one for outgoing messages</li>
<li>Creates a _GlobalErrors exchange for notifying.</li>
<li>Create &quot;Dead Letter Exchang&quot; for this consumer type. (many instances of the same type can be run at the same time, but they share the queue infrastructure).</li>
<li>Create &quot;Dead Letter Queue&quot; for this consumer type and attach to &quot;Dead Letter Exchange&quot;.</li>
<li>Create queue for all registerd handlers, if not exists(operation is idempotent).
<ul>
<li>The Dead Letter Exchange from step 2 is set as the DLE of the queue, meaning that &quot;NACK&quot;ing a message from the queue will send it to this exchange.</li>
<li>Attached queue to exchange provided in the connectioninfo, this exchange has to exists prior to staring the consumer.</li>
<li>Start to listen to messages from queue</li>
</ul>
</li>
</ul>
<h2 id="incomming-type-safe-messages-is-handled-in-this-way">Incomming type safe messages is handled in this way.</h2>
<ul>
<li>Get the routing key for the message, read from properties in the &quot;BasicDevliveryEventArgs&quot;</li>
<li>Deserialize the message to the type matching the routing key. You can controll the how the serializer works by implementing the <code>ISerializer</code> interface</li>
<li>Create instance of handler assosiated with the message, using the provided <code>Action</code> delegate.</li>
<li>Invoke the Handle method on the instance with the message.</li>
<li>ACK is sendt to rabbit, this removes the message from the queue;</li>
</ul>
<h2 id="incomming-wildcard-routings">Incomming wildcard routings</h2>
<ul>
<li>Create a generic message with the body as string.</li>
<li>Instanciate the handler that was registerd with routing key</li>
<li>Call the Handle method</li>
<li>ACK is sendt to rabbit, this removes the message from the queue;</li>
</ul>
<h2 id="when-handling-fails">When handling fails</h2>
<ul>
<li>Message is NACK'ed.</li>
<li>Rabbit will push the message to the Dead Letter Exchange set on the queue, when the queue was created.</li>
<li>A message will be sent to the exchange in step 2 in of the setup.
<ul>
<li>The message is of type</li>
</ul>
</li>
</ul>
<pre><code class="language-csharp">public class ErrorModel
    {
        public string CorrelationId;
        public string MessageType;
        public string HandlerName;
        public string ServerName;
    }
</code></pre>
<p>This can be used to survie the infratructure.</p>
<h3 id="small-example">Small example.</h3>
<pre><code class="language-csharp">static void Main(string[] args)
{
    //Use any container.. 
    var container = new SimpleFactory.Container(LifeTimeEnum.PerGraph);
    container.Register&lt;MessageHandler&lt;MyEventClass&gt;, MyHandler&gt;();
    container.Register&lt;GenericEventHandler&gt;();

    //Connectioninfo to the rabbit server. 
    //The ClientName is important, as it is used in the infrastructure to indentify the host. 
    RabbitConectionInfo connectionInfo = new RabbitConectionInfo { UserName = &quot;guest&quot;, Password = &quot;guest&quot;, Server = &quot;localhost&quot;, ExchangeName = &quot;Simployer&quot;, ClientName = &quot;MyTestingApp&quot; };

    //Create the RabbitAdapter. This is a spesific implementation for Rabbit.
    IMessageAdapter messageAdapter = new RabbitMessageAdapter(
        connectionInfo, 
        //The serializer that will be used by the adapter. This must implement the ISerializer from Itas.Infrastructure.
        new Serializer(), 
        //This Func&lt;BasicDeliveryEventArgs&gt; gives you the chance to create a context value for your eventhandler.
        //Setting the ClientContext e.g
        (e)=&gt; new ClientContext {
            CorrelationId =Guid.Parse(e.BasicProperties.CorrelationId),
            CompanyGuid = Guid.Parse(e.BasicProperties.Headers[Itas.Infrastructure.Context.HeaderNames.User].ToString()) }
        );

    //Then instanciate the MessageHandler.. Passing in the Adapter. 
    var server = new MessageHandlerEngine(
        messageAdapter,
        //This Func&lt;Type,object&gt; is used instead of taking a dependency on a Container. 
        //Here you can create your scope to for your context
        (t,c)=&gt; container.CreateAnonymousInstance(t,c));

    //Register a typed handler for the Engine. 
    //The engine will ask for an instance of  MessageHandle&lt;MyEventClass&gt; using the above Action&lt;Type,object&gt;. 
    server.Register&lt;MyEventClass&gt;();
            
    //Registering an untyped handler. 
    //Will ask for an instance of the type mapped against this bindingkey. 
    server.RegisterExplicit&lt;GenericEventHandler&gt;(&quot;#&quot;);

    //Start the adapter. 
    //The infrastructure will be created on the rabbit server and the adapter will start to recieve the messages. 
    messageAdapter.StartAdapter();

    Console.ReadLine();

    //Stop the Adapter to dispose the connections to Rabbit. 
    messageAdapter.StopAdapter();            
}
                     
</code></pre>

    <script>
        var config = {
            startOnLoad: true,
            flowchart:{
                htmlLabels: false,
                useMaxWidth: true
            },
            width: "800px "
        };
        mermaid.initialize(config);
    </script>
</body>
</html>